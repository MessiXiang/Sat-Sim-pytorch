__all__ = ['SimpleSolarPanel']
from typing import TypedDict

import torch

from satsim.architecture import Module, VoidStateDict, constants
from satsim.utils import mrp_to_rotation_matrix

from ..base import BatteryStateDict, PowerNodeMixin


class SimpleSolarPanelStateDict(TypedDict):
    pass


class SimpleSolarPanel(Module[SimpleSolarPanelStateDict], PowerNodeMixin):

    def __init__(
        self,
        *args,
        panel_normal_B_B: torch.Tensor,
        panel_area: torch.Tensor,
        panel_efficiency: torch.Tensor,
        **kwargs,
    ) -> None:
        """
        Initializes the SimpleSolarPanel object with the given parameters.
        Args:
            panel_normal_B (torch.Tensor): A tensor representing the normal vector
                of the solar panel in the body frame. Must be a non-zero vector.
            panel_area (torch.Tensor): A tensor representing the area of the solar panel.
                Must be a positive value, in m^2.
            panel_efficiency (torch.Tensor): A tensor representing the efficiency of the
                solar panel. Must be within the range (0, 1].
        Raises:
            ValueError: If `panel_area` is not a positive value.
            ValueError: If `panel_efficiency` is not within the range (0, 1].
            ValueError: If `panel_normal_B` is a zero vector.
        Notes:
            The `panel_normal_B` is normalized during initialization.
        """
        super().__init__(*args, **kwargs)

        if torch.any(panel_area <= 0):
            raise ValueError("panel_area must be positive")
        if not torch.all((0 < panel_efficiency) & (panel_efficiency <= 1)):
            raise ValueError("panel_efficiency must be in (0,1]")
        if torch.any(torch.norm(panel_normal_B_B) < 1e-5):
            raise ValueError("direction_BB_B_frame must be normalized")

        panel_normal_B_B = torch.nn.functional.normalize(
            panel_normal_B_B,
            dim=-1,
        )

        self.register_buffer(
            '_panel_normal_B_B',
            panel_normal_B_B,
            persistent=False,
        )
        self.register_buffer(
            '_panel_area',
            panel_area,
            persistent=False,
        )
        self.register_buffer(
            '_panel_efficiency',
            panel_efficiency,
            persistent=False,
        )

    @property
    def panel_normal_B_B(self) -> torch.Tensor:
        return self.get_buffer('_panel_normal_B_B')

    @property
    def panel_area(self) -> torch.Tensor:
        return self.get_buffer('_panel_area')

    @property
    def panel_efficiency(self) -> torch.Tensor:
        return self.get_buffer('_panel_efficiency')

    def forward(
        self,
        state_dict: SimpleSolarPanelStateDict,
        *args,
        position_BN_N: torch.Tensor,
        position_SN_N: torch.Tensor,
        attitude_BN: torch.Tensor,
        shadow_factor: torch.Tensor | None = None,
        battery_state_dict: BatteryStateDict,
        **kwargs,
    ) -> tuple[SimpleSolarPanelStateDict, tuple[torch.Tensor,
                                                BatteryStateDict]]:
        """
        Computes the net power generated by the solar panel given the spacecraft and sun positions, attitude, and optional shadow factor.
        Args:
            state_dict (SolarPanelStateDict): Dictionary containing the current state of the solar panel.
            position_BN_N (torch.Tensor): Tensor of shape (batch_size, 3) representing the spacecraft position in the inertial frame.
            position_SN_N (torch.Tensor): Tensor of shape (batch_size, 3) representing the sun position in the inertial frame.
            attitude_BN (torch.Tensor): Tensor of shape (batch_size, 3) representing the spacecraft attitude in Modified Rodrigues Parameters (MRP).
            shadow_factor (torch.Tensor | None, optional): Tensor of shape (batch_size,) representing the shadowing factor for each sample. If None, assumes full sunlight (no shadow).
        Returns:
            tuple:
                - state_dict (SolarPanelStateDict): Updated state dictionary with computed projected area and sun distance factor.
                - tuple[torch.Tensor]: Tuple containing the net power tensor of shape (batch_size,).
        """

        if shadow_factor is None:
            shadow_factor = 1.

        position_SB_N = position_SN_N - position_BN_N
        position_SB_N_unit = torch.nn.functional.normalize(
            position_SB_N,
            dim=-1,
        )

        direction_cosine_matrix_BN = mrp_to_rotation_matrix(attitude_BN)

        direction_SB_B_unit = torch.einsum(
            "...ij,...j->...i",
            direction_cosine_matrix_BN,
            position_SB_N_unit,
        )

        cos_theta = torch.sum(direction_SB_B_unit * self.panel_normal_B_B,
                              dim=-1)
        projected_area = self.panel_area * torch.clamp(cos_theta, min=0.0)

        position_SB_N_norm = torch.norm(
            position_SB_N,
            dim=-1,
        )
        position_SB_N_norm_factor = (constants.ASTRONOMICAL_UNIT**
                                     2) / (position_SB_N_norm**2 + 1e-10)

        sun_power_factor = (constants.SOLAR_FLUX_AT_EARTH *
                            position_SB_N_norm_factor * shadow_factor)
        net_power = sun_power_factor * projected_area * self.panel_efficiency

        _, battery_state_dict = self.update_power_status(
            net_power, battery_state_dict)

        return state_dict, (net_power, battery_state_dict)
